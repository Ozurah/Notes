Les streams sont la base de la programmation fonctionnelles.

Un stream **<span style="color: red">n'est pas</span>** un : containaire, une collection

On n'y fait pas p√©rsister des donn√©es

Il faut l'imaginer comme un tube, un ruisseau : l'id√©e est de faire **voyager** les donn√©es. Qui dis voyage, dit aventures --> **transformations**

---------

Exemple avec list (avant Java8 : List poss√®de `Add, remove size`)
Apr√®s : Ajout de stream : Notre classe n'impl√©mente plus la nouvelle m√©thode
List | ArrayList | LinkedList | HeArcList (< Java8)
---|---|---|---
add | add | add | add
remove | remove | remove | remove
size | size | size | size
stream | stream | stream | <span style="color: red">Non impl√©ment√©</span>

--> Notre classe ne compile plus si on la modifie pas !
Solution : List impl√©mente la m√©thode `stream` comme √©tant <span style="color: green">une m√©thode par d√©faut</span>

--> Les m√©thodes par d√©faut ont √©t√© initialement introduites pour la m√©thode `stream` (point d'entr√©e de la prog. fonctionnelle en java). Elle c'est ensuite d√©mocratis√© pour permettre aux interfaces d'ajouter de nouvelles m√©thodes sans casser le code existant.

-----

# Utilisation

Aucune donn√©e ne circule dans un stream tant qu'on appel pas une action terminale.

En pratique, on type jamais les streams

M√©thode | Action | Terminal | Remarque
---|---|---|---
list.stream() | cr√©√© le stream | non | (! Le stream ne contient rien !)
stream.count() | Ouverture du "robinet" du tuyau (stream) | **Oui** | 
stream.skip(..) | Nombre de donn√©es saut√©es | non | 
stream.limit(..) | Nombre de donn√©es trait√©e | non | 
stream.of() | Cr√©ation d'un stream √† partir d'un tableau |  | <span style="color: red">A √©viter si on a pas l'habitude</span> ! ne fonctionne pas comme esp√©r√©<br><span style="color: #46b7ae; font-style: italic; font-size: 0.85rem">Stream.of(List\<Integer>)<br>// voulu  : Stream\<Integer><br>// obtenu : Stream<List\<Integer>></span><br><span style="color: green">Privil√©gi√© Arrays.stream</span> pour les tableau par exemple
stream.concat() | Concat√©nation de 2 streams | non | imaginer qu'on soude 3 tubes pour en faire un seul
stream.forEach() | Applique une action √† chaque √©l√©ment | **oui** | 
stream.parallel() | **Parall√©lise** le stream | non | 
stream.map() | Applique une transformation √† chaque √©l√©ment | non | `.map()` si on connait le type (exemple int) --> Utiliser **`.mapToInt()`** pour √©viter les wrappers (m√™me s'ils sont masqu√©s) --> <span style="color: green">Gain de performance d'environ *10 !</span><br>&emsp;on obtient un **intStream**
stream.filter() | Applique un filtre pour chaque √©l√©ment | non |
stream.sorted() | Trie les √©l√©ments | non |
stream.collect() | Regroupe les √©l√©ments dans un conteneur | **oui** | https://www.digitalocean.com/community/tutorials/java-stream-collect-method-examples
stream.reduce() | R√©duit les √©l√©ments en un seul | **oui** | https://www.geeksforgeeks.org/stream-reduce-java-examples/
stream.toArray() | Transforme le stream en tableau | **oui** |
stream.sum() | Somme les √©l√©ments | **oui** |
stream.skip() | Sauter des √©l√©ments | non |
stream.limit() | Limiter le nombre d'√©l√©ments | non |
stream.range() | Cr√©er un stream d'entier | non | arguments : debut, fin (non compris)
stream.iterate() | Cr√©er un stream en it√©rant une fonction | non | arguments : valeur de d√©part, fonction d'it√©ration (unaryOperator)<br><span style="color: red">iterate(0, i++) retournerais [0, 0, 0, ...]</span><br><span style="color: orange">iterate(0, ++i) retourne [0, 1, 2, ...]</span><br><span style="color: green">Conseill√© pour √™tre sur : iterate(0, i+1) retourne [0, 1, 2, ...]</span> 

<!-- #region TODO BLOCK --> 
<div style="margin: 20px auto; padding: 10px; background-color: #ffd48a; border-left: 5px solid #8a5700;color: black; font-size: 2em">
<span> üìù </span>TODO<br>
<span style="font-size: 0.75em">
Integrer ces infos dans nouvelle colonne tableau pr√©c√©dent
</span></div>

<!-- #endregion TODO BLOCK -->


*m√©thode(ce que √ßa mange)*

map(function)
filter(predicate
sort(rien ou predicator
skip(nombre)
limit(nombre)
parral√®le(rien)

count rien
toArray(stream sp√©cialis√© rien ou stream d'objet : un g√©n√©rateur) // on donne mapping; exemple si on veut un tableau de bananne : IntFunction<Banane[]> (le int pour la dimension)
    expr lambda : n->new Banane[n]
    ref de m√©thode : Banane[]::new
collect(Collectors
reduce(binary operator et valeur d'init
foreach(consummer
sum(rien)
<!-- #region TODO BLOCK --> 
<div style="margin: 20px auto; padding: 10px; background-color: #ffd48a; border-left: 5px solid #8a5700;color: black; font-size: 2em">
<span> üìù </span>FIN TODO<br>
</div>

<!-- #endregion TODO BLOCK -->



Stream sur un it√©rable : Utiliser la classe `Streams.stream(iterable)` homemade du prof. <span style="color: #46b7ae; font-style: italic; font-size: 0.85rem">// C'est tr√®s complexe √† faire sinon</span> 
