Les streams sont la base de la programmation fonctionnelles.

Un stream **<span style="color: red">n'est pas</span>** un : containaire, une collection

On n'y fait pas p√©rsister des donn√©es

Il faut l'imaginer comme un tube, un ruisseau : l'id√©e est de faire **voyager** les donn√©es. Qui dis voyage, dit aventures --> **transformations**

---------

Exemple avec list (avant Java8 : List poss√®de `Add, remove size`)
Apr√®s : Ajout de stream : Notre classe n'impl√©mente plus la nouvelle m√©thode
| List   | ArrayList | LinkedList | HeArcList (< Java8)                            |
| ------ | --------- | ---------- | ---------------------------------------------- |
| add    | add       | add        | add                                            |
| remove | remove    | remove     | remove                                         |
| size   | size      | size       | size                                           |
| stream | stream    | stream     | <span style="color: red">Non impl√©ment√©</span> |

--> Notre classe ne compile plus si on la modifie pas !
Solution : List impl√©mente la m√©thode `stream` comme √©tant <span style="color: green">une m√©thode par d√©faut</span>

--> Les m√©thodes par d√©faut ont √©t√© initialement introduites pour la m√©thode `stream` (point d'entr√©e de la prog. fonctionnelle en java). Elle c'est ensuite d√©mocratis√© pour permettre aux interfaces d'ajouter de nouvelles m√©thodes sans casser le code existant.

-----

# Utilisation

Aucune donn√©e ne circule dans un stream tant qu'on appel pas une action terminale.

En pratique, on type jamais les streams

| M√©thode           | Action                                       | Terminal | Remarque                                                                                                                                                                                                                                                                                                                                                                   |
| ----------------- | -------------------------------------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| list.stream()     | cr√©√© le stream                               | non      | (! Le stream ne contient rien !)                                                                                                                                                                                                                                                                                                                                           |
| stream.count()    | Ouverture du "robinet" du tuyau (stream)     | **Oui**  |
| stream.skip(..)   | Nombre de donn√©es saut√©es                    | non      |
| stream.limit(..)  | Nombre de donn√©es trait√©e                    | non      |
| stream.of()       | Cr√©ation d'un stream √† partir d'un tableau   |          | <span style="color: red">A √©viter si on a pas l'habitude</span> ! ne fonctionne pas comme esp√©r√©<br><span style="color: #46b7ae; font-style: italic; font-size: 0.85rem">Stream.of(List\<Integer>)<br>// voulu  : Stream\<Integer><br>// obtenu : Stream<List\<Integer>></span><br><span style="color: green">Privil√©gi√© Arrays.stream</span> pour les tableau par exemple |
| stream.concat()   | Concat√©nation de 2 streams                   | non      | imaginer qu'on soude 3 tubes pour en faire un seul                                                                                                                                                                                                                                                                                                                         |
| stream.forEach()  | Applique une action √† chaque √©l√©ment         | **oui**  |
stream.peek() | Applique une action √† chaque √©l√©ment | non | <span style="color: #46b7ae; font-style: italic; font-size: 0.85rem">Peut √™tre utilis√© pour du debug</span> |
| stream.parallel() | **Parall√©lise** le stream                    | non      |
| stream.map()      | Applique une transformation √† chaque √©l√©ment | non      | `.map()` si on connait le type (exemple int) --> Utiliser **`.mapToInt()`** pour √©viter les wrappers (m√™me s'ils sont masqu√©s) --> <span style="color: green">Gain de performance d'environ *10 !</span><br>&emsp;on obtient un **intStream**<br>`mapToObj()` est aussi un type existant                                                                                   |
| stream.filter()   | Applique un filtre pour chaque √©l√©ment       | non      |
| stream.sorted()   | Trie les √©l√©ments                            | non      |
| stream.collect()  | Regroupe les √©l√©ments dans un conteneur      | **oui**  | https://www.digitalocean.com/community/tutorials/java-stream-collect-method-examples                                                                                                                                                                                                                                                                                       |
| stream.reduce()   | R√©duit les √©l√©ments en un seul               | **oui**  | https://www.geeksforgeeks.org/stream-reduce-java-examples/                                                                                                                                                                                                                                                                                                                 |
| stream.toArray()  | Transforme le stream en tableau              | **oui**  |
| stream.sum()      | Somme les √©l√©ments                           | **oui**  |
| stream.skip()     | Sauter des √©l√©ments                          | non      |
| stream.limit()    | Limiter le nombre d'√©l√©ments                 | non      |
| stream.range()    | Cr√©er un stream d'entier                     | non      | arguments : debut, fin (non compris)                                                                                                                                                                                                                                                                                                                                       |
| stream.iterate()  | Cr√©er un stream en it√©rant une fonction      | non      | arguments : valeur de d√©part, fonction d'it√©ration (unaryOperator)<br><span style="color: red">iterate(0, i++) retournerais [0, 0, 0, ...]</span><br><span style="color: orange">iterate(0, ++i) retourne [0, 1, 2, ...]</span><br><span style="color: green">Conseill√© pour √™tre sur : iterate(0, i+1) retourne [0, 1, 2, ...]</span>                                     |
anyMatch() | V√©rifie si au moins un √©l√©ment correspond √† la condition | **oui** | param√®tre : `Predicate<T>`, exemple pour des nombres paire : `n -> n % 2 == 0` |
allMatch() | V√©rifie si tous les √©l√©ments correspondent √† la condition | **oui** | |
min() / max() | Retourne le minimum / maximum | **oui** | |
argmin() / argmax() | Retourne l'index du minimum / maximum | **oui** | |
flatMap() | Permet de d√©grouper | non | [cf FlatMap](#flatmap) |

<!-- #region TODO BLOCK --> 
<div style="margin: 20px auto; padding: 10px; background-color: #ffd48a; border-left: 5px solid #8a5700;color: black; font-size: 2em">
<span> üìù </span>TODO<br>
<span style="font-size: 0.75em">
Integrer ces infos dans nouvelle colonne tableau pr√©c√©dent
</span></div>

<!-- #endregion TODO BLOCK -->


*m√©thode(ce que √ßa mange)*

map(function)
filter(predicate
sort(rien ou predicator
skip(nombre)
limit(nombre)
parral√®le(rien)

count rien
toArray(stream sp√©cialis√© rien ou stream d'objet : un g√©n√©rateur) // on donne mapping; exemple si on veut un tableau de bananne : IntFunction<Banane[]> (le int pour la dimension)
    expr lambda : n->new Banane[n]
    ref de m√©thode : Banane[]::new
collect(Collectors
reduce(binary operator et valeur d'init
foreach(consummer
sum(rien)
<!-- #region TODO BLOCK --> 
<div style="margin: 20px auto; padding: 10px; background-color: #ffd48a; border-left: 5px solid #8a5700;color: black; font-size: 2em">
<span> üìù </span>FIN TODO<br>
</div>

<!-- #endregion TODO BLOCK -->


# Stream sur un it√©rable
Stream sur un it√©rable : Utiliser la classe `Streams.stream(iterable)` homemade du prof. <span style="color: #46b7ae; font-style: italic; font-size: 0.85rem">// C'est tr√®s complexe √† faire sinon</span> 


# Quand utiliser "...ToX" ?
les "toX" sont √† utiliser quand le type du stream change
 - exemple on veut faire une action qui retourne des doubles depuis un int; puis on veut faire une autre action qui retourne √©galement des double, puis une derni√®re action qui retourne un entier : `IntStream.mapToDouble(action1).map(action2).mapToInt(action3)`

# Retourne "Optional"

R√©sultat d'une stream est optional si le r√©sultat du stream n'est pas d√©fini quand une stream est vide.

M√©thodes retournant des optionals :
 - `findFirst()`
 - `findAny()`
 - `max()`
 - `min()`
 - `reduce()`
 - `collect()`

Attention √† ces pi√®ges : 
 - <span style="color: red">~~count~~</span> : retourne 0 si vide


# flatMap

Stream<int[]>			-> flatMap ->	IntStream
Stream<String[]>		-> flatMap ->	Stream<String>
Stream<Set<String>>		-> flatMap ->	Stream<String>
Stream<List<String>>	-> flatMap ->	Stream<String>
Stream<List<Object>>	-> flatMap ->	Stream<Object>

## Exemple avec et sans flatMap
```java
private static void defi()
{
    int[] v1 = { 1, 11, 111 };
    int[] v2 = { 2, 22, 222 };
    int[] v3 = { 3, 33, 333 };

    int[][] tabVectors = { v1, v2, v3 }; // un tableau 2D!

    // BUT :    Afficher sous cette forme tabVector
    //
    //			1
    //			11
    //			111
    //			2
    //			22
    //			222
    //			3
    //			33
    //			333
    //
    // Contrainte : Interdit d'utiliser un flatmap
    // Indication : Utiliser la methode concat static de Stream

    //Arrays.stream(tabVectors)// TODO
    
    // V1.1
    {
        Arrays.stream(tabVectors) // Stream<int[]>
            .map(v -> Arrays.stream(v)) // Stream<IntStream>
            .reduce((s1, s2) -> IntStream.concat(s1, s2)) // Optional<IntStream>
            .get() // IntStream
            .forEach(System.out::println);
    }
    // V1.1
    {
        Arrays.stream(tabVectors) // Stream<int[]>
            .map(Arrays::stream) // Stream<IntStream>
            .reduce(IntStream::concat) // Optional<IntStream>
            .get() // IntStream
            .forEach(System.out::println);
    }
    // V2
    {
        Arrays.stream(tabVectors) // Stream<int[]>
            .map(Arrays::stream) // Stream<IntStream>
            .reduce(IntStream.empty(), IntStream::concat) // IntStream
            .forEach(System.out::println);
    }
    // V3
    {
        TODO
    }
}
```

<!-- #region TODO BLOCK --> 
<div style="margin: 20px auto; padding: 10px; background-color: #ffd48a; border-left: 5px solid #8a5700;color: black; font-size: 2em">
<span> üìù </span>TODO<br>
<span style="font-size: 0.75em">
COMPLETER LA V3 !
Ajouter sch√©ma de l'√©nonc√© (papier)
Le flatmap to double (ligne ~200)

le code se trouve dans `c_flatmap.use...`
</span></div>

<!-- #endregion TODO BLOCK -->

## flatMapToX

exemple `flatmapToDouble` : 
```java
```

<!-- #region TODO BLOCK --> 
<div style="margin: 20px auto; padding: 10px; background-color: #ffd48a; border-left: 5px solid #8a5700;color: black; font-size: 2em">
<span> üìù </span>TODO<br>
<span style="font-size: 0.75em">
Cours 10h-10h45
</span></div>

<!-- #endregion TODO BLOCK -->


On fait en s√©quentiel, puis on ajoute le parralel ;D