D√©finition : Qu'est-ce qui faut √† une machine pour ce faire passer par un humain.
> Le test de turing est le 1er test le permettant. 
>> principe : Un examinateur pause une question √† 2 salles (sans savoir qui est dedans) (1 salle = 1 machine; l'autre un humain)
>>>les 2 r√©pondent par √©crits √† cette question.
L'examinateur re√ßois les r√©ponses, et s'il penses que le texte √©crit par la machine est humain, alors la machine √† passer le test !
>
>>>Ce qu'il faudrait √† l'ordi pour le passer :
>>> - Traitement, traiter le langage naturel pour communiquer dans la langue humaine
>>> - Repr√©senter la connaissance : stocker et r√©utiliser les connaissances acquises
>>> - Raisonner automatiquement : r√©pondre et apprendre des questions
>>> - Machine learning : s'adapter aux nouvelles circonstances et d√©tecter/identifier des r√©curences

> Def 2 : C'est la construction d'un programmes informatiques qui peuvent faire ce que les humains font de mani√®re automne, en ayant un raisonnement critique, l'apprentissage perceptuel, etc.


Cat√©gories : penser/agir humainement/rationnellement

------

> <span style="font-size: 1.5em">üìñ</span> <span style="color: yellow; font-size: 1.3em;">Pr√©sentation [1.1 Recherche aveugle](https://cyberlearn.hes-so.ch/pluginfile.php/4079850/mod_resource/content/0/01_1_Algos-Recherche_Aveugle.pdf)</span>


Strat√©gie de recherche  (slide 24)
-   Compl√©tude  :   Permet-elle de trouver une solution s'il en existe une dans tout les cas ?
-   Complexit√© en temps : Nombre de noeuds g√©n√©r√©s pour trouver la solution
    -   Combien de temps pour trouver la solution  
    -   Complexit√© en espace    :   Nombre maximalde noeuds travers√©/m√©moris√©
        -   Combien de m√©moire pour effectuer la recherche
    -   Optimalit√©  :   permet de toujours trouver le chemin le moins couteux (le plus court)

Mesurer la complexit√© temps/espace (slide 25):
- b (branche) : nombre d'arc (branches) sortant maximal de tout les noeuds de l'arbre
- d (depth) : profondeur du chemin le plus court vers le but
- m (profondeur max) : Longueur max de n'importe quel chemin


# Exercice parcours en profondeur it√©rative (slide 57)
        S√©quence : 
            L=0	A
            L=1	ABC
            L=2	ABCDEFG
            L=3	ABCDEFGHIJ

        --> Nombre de noeuds parcourus : 1 + 3 + 7 + 10 = 21 

(pour le cours on part de la racine)

------

# 27.09.2022 

# R√©vision - mots cl√©s
recherche aveugle

Diagramme d'√©tat-transition

Type de strat√©gie :
    parcours en profondeur (**D**epth **F**irst **S**earch)
    Parcours en largeur (**B**readth **F**irst **S**earch)
    Parcours en profondeur it√©rative (**I**terative **D**eepening)

![](Screen/2022-09-27-13-28-20.png)

Complexit√© avec "m" pour DFS et "d" pour BFS car 
- m : on connais pas la profondeur maximale, il peut donc y avoir un nombre infini de noeuds
- d : on parcours chaque noeud √† chaque √©tage

Remarque : m quand non optimal, d quand optimal

**Arbre vs graphe** :
- Arbre : pas de cycle
- Arbre : poss√®de une racine
- Arbre : forc√©ment orient√© (racine vers feuilles)

# Pseudo-code
## DFS
```
dfs(A) : 
    N = D√©piler(N)
    enfants(N)
    Pousser(enfants)
    Visiter(N)
```

# Impl√©mentations de l'√©tat
![](Screen/2022-09-27-13-44-43.png)