# JEE/Spring 

> <span style="font-size: 1.5em">üìñ</span> <span style="color: orange; font-size: 1.3em;">Pr√©sentation `Chapitre Introduction`</span>


----------------

**Monolithe / microservice :**
- **Monolithe** == tout dans 1 seul package --> d√©ploiement sur le servuer, faut tout red√©ploy√©
- **microservice** == s√©par√© en plusieurs package --> d√©ploiement sur le serveur, red√©ploiement que des packets modifi√©s

----

Pour les `@ResponseBody`, Spring convertie automatiquement les objets en JSON
Si l'on souhaite du XML, il suffit de changer 1 d√©pendance



Ent√™te de m√©thode pour des requ√™tes HTTP (les 2 sont les m√™mes)
```java
@GetMapping(value = {"/hello4/{nom}", "/hello4"})
@RequestMappping(value = {"/hello4/{nom}", "/hello4"}, method = RequestMethod.GET)
```

`@RequestMapping({"/test"})` Au dessus d'une classe permet d'indiquer l'url pr√©fix pour toutes les pages de la classe
Exemple d'url : `http://localhost:8081/test/hello4`

----

Beans : Dans le contexte java; il s'agit d'un **objet** Spring, cr√©√©, g√©r√© et d√©truit par spring

----

# Architecture
_Client_ <-> Controller <-> Service <-> Repository (DAO) <-> Stockage
- Controller : expose les actions GET/POST, les routes, etc. +validation (limites/type, etc) de donn√©es ici aussi
- Service : la couche m√©tier (l'impl√©mentation des actions POST)
- Repository : la couche d'acc√®s aux donn√©es (bdd, excel, txt, etc)

![](Screen/2022-10-04-11-53-11.png)
![](Screen/2022-10-04-11-53-01.png)


Pour les classes "Repository" on en fait 2 par objets :
- `repository/XXXRepository` : interface qui contient les m√©thodes de requ√™tes
- `repository/impl/XXXMemoryRepository` : classe qui impl√©mente les m√©thodes de l'interface (acc√®s au stockage, bdd, etc)

----

# Injection de d√©pendances (IoC)
IoC = Inversion of Control
Injection de d√©pendances = m√©canisme qui permet de cr√©er des objets et de les lier entre eux

Mot cl√© @ | Effet | Remarque/Exemple
---|---|---
`@postConstruct` | m√©thode qui s'execute apr√®s la cr√©ation de l'objet
`@autowired` | permet d'injecter une d√©pendance dans un objet | se d√©fini sur des attributs
`@bean` | permet de cr√©er un objet Spring | se d√©fini sur des m√©thodes

@autowired : dit "cherche moi cette classe, stock l√† dans la variable" et apr√®s on peut l'utiliser (on ne cr√©√© nul part un `new` ou autre). Pour que le la classe puisse √™tre prise, il faut qu'elle soit √† choix `@Component`, `@Service`, `@Repository`, `@Controller` (en soit c'est un peu comme un `Singleton`).

![](Screen/2022-10-18-11-43-12.png)

![](Screen/2022-10-25-11-22-53.png)

Spring g√®re aussi bien les fichiers "XML + JAVA" que "JAVA + Annotation"

les annotations permettent d'avoir que des fichiers java, mais deviennent d√©pendantes de Spring,
alors que le XML va li√© les classes java entre elle, ainsi le code java reste ind√©pendant de Spring.

Slide importante : https://cyberlearn.hes-so.ch/mod/book/view.php?id=1867182&chapterid=9550 (`IOC - INVERSION OF CONTROL > 4. COMPONENT VS BEAN`)

# R√©flexion (ou introspection)
La **reflection** (parfois appel√© introspection) est la facult√© pur un langage de pouvoir agir sur les m√©ta-donn√©es des √©l√©ments du logiciel (classes, m√©thodes, ex√©cution).

La reflection est au c≈ìur du m√©canisme de Spring (chargement des classes, traitement des annotations, etc...)

# Logging (package AOP)

slide : https://cyberlearn.hes-so.ch/mod/book/view.php?id=1869061&chapterid=9541

ajouter ces d√©pendances dans le pom.xml
```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

Exemple de code pour logger dans la console :
```java
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class AspectController {
    //               quand  port√©e   package.class.method(..)   // .. == 0-n param
    @Before(value = "execution(* ch.hearc.jee2022.helloworld.HelloController.*(..))")
    public void beforeAdvice(JoinPoint joinPoint) {
			//loggue de la signature de la mt√©hode appel√©e
		System.out.println("Before method:" + joinPoint.getSignature());
			
		//Loggue des param√®tres si pr√©sents
		System.out.println("Before method, arguments: :" );
			
		for(Object object : joinPoint.getArgs()) {				
            System.out.println(object);
		}
	}
}
```

![](Screen/2022-10-25-11-39-46.png)
- la classe demande d'avoir les annotations `@Aspect` et `@Component` pour √™tre pris en compte par Spring
- **`@Aspect`** permet de dire que c'est une classe qui va √™tre modulis√©e (utilis√©e dans plusieurs classes)
- **before** : execute ceci avant l'execution de chaque m√©thode (priv√©e ou publique) respectant le pr√©dicat
  - Contenu du before : <span style="color: #46b7ae; font-style: italic; font-size: 0.85rem">// quand  port√©e   package.class.method(..)   // .. == 0-n param</span> 
- **JoinPoint** : m√©thode qui va √™tre execut√© par le controlleur
  - un JoinPoint c'est l'annotation @GetMapping au dessus de la m√©thode